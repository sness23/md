<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live MD Demo (OpenMM → Babylon.js CPK Viewer)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1220; color: #e6edf7; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding: 12px 16px; border-bottom: 1px solid #243042; display: flex; align-items: center; gap: 16px; }
    main { height: calc(100% - 54px); display: grid; grid-template-columns: 1fr 320px; }
    #viewer { width: 100%; height: 100%; touch-action: none; }
    #sidebar { padding: 12px; border-left: 1px solid #243042; overflow: auto; }
    button { background: #243042; color: #e6edf7; border: none; padding: 8px 12px; border-radius: 10px; cursor: pointer; }
    button:hover { background: #2d3b50; }
    input[type=number] { width: 80px; background: #0f172a; color: #e6edf7; border: 1px solid #243042; padding: 4px; border-radius: 4px; }
    a { color: #9cdcfe; }
    code { background: #0f172a; padding: 2px 6px; border-radius: 6px; }
  </style>
  <!-- Babylon.js from CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <header>
    <strong>Live MD Demo</strong>
    <span>OpenMM → Babylon.js CPK Viewer</span>
    <span id="status">loading…</span>
  </header>
  <main>
    <canvas id="viewer"></canvas>
    <div id="sidebar">
      <h3>Controls</h3>
      <p>CPK sphere representation. Mouse: rotate (left), pan (right), zoom (wheel).</p>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <button id="playpause">Pause</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <label>Poll (s) <input id="pollSecs" type="number" value="5" min="1" /></label>
        <button id="togglePoll">Start Polling</button>
      </div>
      <p>Frame: <code id="frame-info">0/0</code></p>
      <p>Atoms: <code id="atom-count">0</code></p>
      <hr />
      <p><small>Live trajectory streaming with Babylon.js</small></p>
    </div>
  </main>
  <script type="module">
    const statusEl = document.getElementById('status')
    const frameInfoEl = document.getElementById('frame-info')
    const atomCountEl = document.getElementById('atom-count')
    const playPauseBtn = document.getElementById('playpause')
    const pollSecsInput = document.getElementById('pollSecs')
    const togglePollBtn = document.getElementById('togglePoll')

    let polling = false
    let pollTimer = null
    let currentBytes = 0
    let playing = true
    let currentFrame = 0
    let frames = []
    let atoms = []
    let atomSpheres = []

    // CPK colors (RGB 0-1)
    const CPK_COLORS = {
      'H': [1.0, 1.0, 1.0],    // white
      'C': [0.5, 0.5, 0.5],    // gray
      'N': [0.2, 0.2, 1.0],    // blue
      'O': [1.0, 0.2, 0.2],    // red
      'S': [1.0, 1.0, 0.0],    // yellow
      'P': [1.0, 0.5, 0.0],    // orange
    }

    // CPK radii in angstroms
    const CPK_RADII = {
      'H': 0.25, 'C': 0.7, 'N': 0.65, 'O': 0.6, 'S': 1.0, 'P': 1.0
    }

    // Babylon.js setup
    const canvas = document.getElementById('viewer')
    const engine = new BABYLON.Engine(canvas, true)
    const scene = new BABYLON.Scene(engine)
    scene.clearColor = new BABYLON.Color3(0.043, 0.071, 0.125)

    const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 30, BABYLON.Vector3.Zero(), scene)
    camera.attachControl(canvas, true)
    camera.wheelPrecision = 50
    camera.lowerRadiusLimit = 5
    camera.upperRadiusLimit = 100

    const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene)
    light.intensity = 0.8

    engine.runRenderLoop(() => scene.render())
    window.addEventListener('resize', () => engine.resize())

    // WASD + QE camera controls
    const keys = {}
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true)
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false)

    const moveSpeed = 0.5
    scene.registerBeforeRender(() => {
      const forward = camera.target.subtract(camera.position).normalize()
      const right = BABYLON.Vector3.Cross(forward, camera.upVector).normalize()
      const up = camera.upVector

      if (keys['w']) {
        camera.position.addInPlace(forward.scale(moveSpeed))
        camera.target.addInPlace(forward.scale(moveSpeed))
      }
      if (keys['s']) {
        camera.position.addInPlace(forward.scale(-moveSpeed))
        camera.target.addInPlace(forward.scale(-moveSpeed))
      }
      if (keys['a']) {
        camera.position.addInPlace(right.scale(-moveSpeed))
        camera.target.addInPlace(right.scale(-moveSpeed))
      }
      if (keys['d']) {
        camera.position.addInPlace(right.scale(moveSpeed))
        camera.target.addInPlace(right.scale(moveSpeed))
      }
      if (keys['q']) {
        camera.position.addInPlace(up.scale(-moveSpeed))
        camera.target.addInPlace(up.scale(-moveSpeed))
      }
      if (keys['e']) {
        camera.position.addInPlace(up.scale(moveSpeed))
        camera.target.addInPlace(up.scale(moveSpeed))
      }
    })

    // Parse PDB file
    function parsePDB(text) {
      const lines = text.split('\n')
      const parsedAtoms = []
      for (const line of lines) {
        if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
          const element = line.substring(76, 78).trim() || line.substring(12, 14).trim().charAt(0)
          const x = parseFloat(line.substring(30, 38))
          const y = parseFloat(line.substring(38, 46))
          const z = parseFloat(line.substring(46, 54))
          parsedAtoms.push({ element, x, y, z })
        }
      }
      return parsedAtoms
    }

    // Parse DCD binary file
    function parseDCD(arrayBuffer) {
      try {
        const view = new DataView(arrayBuffer)
        let offset = 0

        // First block: main header
        console.log('Parsing header at offset:', offset, 'bufferSize:', arrayBuffer.byteLength)
        const hdrSize = view.getInt32(offset, true); offset += 4
        console.log('hdrSize:', hdrSize, 'offset:', offset)

        // Read the block content (hdrSize bytes)
        const magic = new TextDecoder('ascii').decode(new Uint8Array(arrayBuffer, offset, 4)); offset += 4
        console.log('magic:', magic, 'offset:', offset)
        const nFrames = view.getInt32(offset, true); offset += 4
        console.log('nFrames:', nFrames, 'offset:', offset)

        // Skip to the end of this block
        offset = 4 + hdrSize  // Jump to end marker position
        console.log('Jumping to end of header block at offset:', offset)
        const hdrEnd = view.getInt32(offset, true); offset += 4  // Should match hdrSize
        console.log('hdrEnd:', hdrEnd, 'should match hdrSize:', hdrSize, 'offset:', offset)

        // Second block: title (skip entire block using titleSize)
        console.log('Reading title at offset:', offset)
        const titleSize = view.getInt32(offset, true); offset += 4
        console.log('titleSize:', titleSize, 'offset:', offset)
        offset += titleSize  // Skip entire title block content
        const titleEnd = view.getInt32(offset, true); offset += 4
        console.log('titleEnd:', titleEnd, 'should match titleSize:', titleSize, 'offset:', offset)

        // Third block: natoms
        const natSize = view.getInt32(offset, true); offset += 4  // Should be 4
        const nAtoms = view.getInt32(offset, true); offset += 4
        const natEnd = view.getInt32(offset, true); offset += 4

        console.log('DCD header:', { magic, nFrames, nAtoms, hdrSize, natSize, offset })

        // Check if DCD has unit cell info (peek at first block size)
        const firstBlockSize = view.getInt32(offset, true)
        const hasUnitCell = firstBlockSize === 48 // 48 bytes = 6 doubles for unit cell
        console.log('First block size:', firstBlockSize, 'hasUnitCell:', hasUnitCell)

        // Read frames - only read frames that actually exist in the buffer
        const parsedFrames = []
        const unitCellBytes = hasUnitCell ? 56 : 0 // 4 (size) + 48 (data) + 4 (size)
        const bytesPerFrame = unitCellBytes + 3 * (8 + nAtoms * 4) // unit cell + 3 coords * (header + data + footer)
        const maxPossibleFrames = Math.floor((arrayBuffer.byteLength - offset) / bytesPerFrame)
        const actualFrames = Math.min(nFrames, maxPossibleFrames)

        console.log('nFrames from header:', nFrames, 'maxPossible:', maxPossibleFrames, 'will read:', actualFrames)

        for (let f = 0; f < actualFrames; f++) {
          // Check if we have enough bytes left for a complete frame
          const remainingBytes = arrayBuffer.byteLength - offset
          if (remainingBytes < bytesPerFrame) {
            console.warn('Incomplete frame', f, '- stopping parse')
            break
          }

          // Skip unit cell data if present
          if (hasUnitCell) {
            const cellBlockSize = view.getInt32(offset, true); offset += 4
            offset += cellBlockSize // Skip the 48 bytes of unit cell data
            const cellBlockEnd = view.getInt32(offset, true); offset += 4
          }

          const coords = { x: [], y: [], z: [] }

          // X coordinates
          const xBlockSize = view.getInt32(offset, true); offset += 4
          if (f === 0) console.log('Frame 0 X block size:', xBlockSize, 'expected:', nAtoms * 4)
          for (let i = 0; i < nAtoms; i++) {
            coords.x.push(view.getFloat32(offset, true))
            offset += 4
          }
          const xBlockEnd = view.getInt32(offset, true); offset += 4
          if (f === 0 && xBlockSize !== xBlockEnd) {
            console.warn('X block size mismatch:', xBlockSize, '!=', xBlockEnd)
          }

          // Y coordinates
          const yBlockSize = view.getInt32(offset, true); offset += 4
          for (let i = 0; i < nAtoms; i++) {
            coords.y.push(view.getFloat32(offset, true))
            offset += 4
          }
          const yBlockEnd = view.getInt32(offset, true); offset += 4

          // Z coordinates
          const zBlockSize = view.getInt32(offset, true); offset += 4
          for (let i = 0; i < nAtoms; i++) {
            coords.z.push(view.getFloat32(offset, true))
            offset += 4
          }
          const zBlockEnd = view.getInt32(offset, true); offset += 4

          parsedFrames.push(coords)
        }

        console.log('Parsed frames:', parsedFrames.length)
        return parsedFrames
      } catch (err) {
        console.error('DCD parse error:', err)
        return []
      }
    }

    // Create atom spheres
    function createAtoms() {
      atomSpheres.forEach(s => s.dispose())
      atomSpheres = []

      // Calculate center of mass
      let cx = 0, cy = 0, cz = 0
      for (const atom of atoms) {
        cx += atom.x
        cy += atom.y
        cz += atom.z
      }
      cx /= atoms.length
      cy /= atoms.length
      cz /= atoms.length

      console.log('Molecule center:', cx, cy, cz)

      for (let i = 0; i < atoms.length; i++) {
        const atom = atoms[i]
        const element = atom.element
        const radius = CPK_RADII[element] || 0.7
        const color = CPK_COLORS[element] || [0.8, 0.8, 0.8]

        const sphere = BABYLON.MeshBuilder.CreateSphere(`atom${i}`, { diameter: radius * 2, segments: 12 }, scene)
        const material = new BABYLON.StandardMaterial(`mat${i}`, scene)
        material.diffuseColor = new BABYLON.Color3(...color)
        material.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3)
        sphere.material = material

        sphere.position.x = atom.x
        sphere.position.y = atom.y
        sphere.position.z = atom.z

        atomSpheres.push(sphere)
      }

      // Center camera on molecule
      camera.target = new BABYLON.Vector3(cx, cy, cz)
      camera.radius = Math.max(30, atoms.length * 0.15) // Adjust zoom based on molecule size

      atomCountEl.textContent = atoms.length
    }

    // Update atom positions for current frame
    function updateFrame() {
      if (frames.length === 0) {
        console.log('updateFrame: no frames')
        return
      }

      const frame = frames[currentFrame]
      if (!frame) {
        console.log('updateFrame: frame', currentFrame, 'is undefined')
        return
      }

      for (let i = 0; i < atomSpheres.length && i < frame.x.length; i++) {
        atomSpheres[i].position.x = frame.x[i]
        atomSpheres[i].position.y = frame.y[i]
        atomSpheres[i].position.z = frame.z[i]
      }

      frameInfoEl.textContent = `${currentFrame + 1}/${frames.length}`
    }

    // Animation loop
    let animateStarted = false
    let frameCounter = 0
    let lastFrameTime = 0
    const frameInterval = 50 // 20 fps (50ms between frames)

    function animate(timestamp) {
      if (!animateStarted) {
        console.log('Animation loop started, playing:', playing, 'frames:', frames.length)
        animateStarted = true
        lastFrameTime = timestamp
      }

      // Update at ~20fps regardless of render rate
      if (timestamp - lastFrameTime >= frameInterval) {
        if (playing && frames.length > 0) {
          currentFrame = (currentFrame + 1) % frames.length
          updateFrame()
          frameCounter++
          if (frameCounter % 100 === 0) {
            console.log('Animation frame:', currentFrame, 'counter:', frameCounter)
          }
        }
        lastFrameTime = timestamp
      }

      requestAnimationFrame(animate)
    }

    async function getConfig() {
      const res = await fetch('/api/config')
      if (!res.ok) throw new Error('Config fetch failed')
      return await res.json()
    }

    async function headSize(url) {
      const res = await fetch(url, { method: 'HEAD' })
      if (!res.ok) return 0
      const len = res.headers.get('content-length')
      return len ? Number(len) : 0
    }

    async function loadAll() {
      const cfg = await getConfig()
      const base = cfg.mdsrvUrl.replace(/\/$/, '')
      const pdbUrl = base + '/data/' + cfg.topology
      const dcdUrl = base + '/data/' + cfg.trajectory

      statusEl.textContent = 'loading structure…'
      const pdbRes = await fetch(pdbUrl)
      const pdbText = await pdbRes.text()
      atoms = parsePDB(pdbText)
      console.log('Loaded atoms:', atoms.length)

      createAtoms()

      statusEl.textContent = 'loading trajectory…'
      const dcdRes = await fetch(dcdUrl)
      const dcdBuffer = await dcdRes.arrayBuffer()
      console.log('DCD buffer size:', dcdBuffer.byteLength)
      frames = parseDCD(dcdBuffer)
      console.log('Loaded frames:', frames.length)

      // Validate frame data matches atom count
      if (frames.length > 0 && frames[0].x.length !== atoms.length) {
        console.error('Atom count mismatch! PDB:', atoms.length, 'DCD frame:', frames[0].x.length)
        statusEl.textContent = `error: atom count mismatch (PDB: ${atoms.length}, DCD: ${frames[0].x.length})`
        return
      }

      // Check if frames differ
      if (frames.length > 1) {
        console.log('Frame 0, atom 0:', frames[0].x[0], frames[0].y[0], frames[0].z[0])
        console.log('Frame 1, atom 0:', frames[1].x[0], frames[1].y[0], frames[1].z[0])
        if (frames.length > 100) {
          console.log('Frame 100, atom 0:', frames[100].x[0], frames[100].y[0], frames[100].z[0])
        }
      }

      if (frames.length > 0) {
        currentFrame = 0
        updateFrame()
      }

      currentBytes = await headSize(dcdUrl)
      statusEl.textContent = 'ready'
      requestAnimationFrame(animate)
    }

    async function checkForNewFrames() {
      const cfg = await getConfig()
      const base = cfg.mdsrvUrl.replace(/\/$/, '')
      const dcdUrl = base + '/data/' + cfg.trajectory
      const size = await headSize(dcdUrl)

      if (size > currentBytes) {
        const oldFrameCount = frames.length
        currentBytes = size
        statusEl.textContent = 'loading new frames…'

        // Retry logic for partial DCD reads
        let retries = 3
        let newFrames = []
        while (retries > 0) {
          try {
            const dcdRes = await fetch(dcdUrl + '?t=' + Date.now())
            const dcdBuffer = await dcdRes.arrayBuffer()
            newFrames = parseDCD(dcdBuffer)
            if (newFrames.length > 0) break
          } catch (err) {
            console.warn('DCD parse error, retrying...', err)
            await new Promise(r => setTimeout(r, 500)) // Wait 500ms before retry
          }
          retries--
        }

        if (newFrames.length > 0) {
          frames = newFrames
          const newFrameCount = frames.length - oldFrameCount
          if (newFrameCount > 0) {
            statusEl.textContent = `loaded ${newFrameCount} new frames`
            setTimeout(() => statusEl.textContent = 'ready', 2000)
          } else {
            statusEl.textContent = 'ready'
          }
        } else {
          statusEl.textContent = 'parse error - will retry next poll'
        }
      }
    }

    playPauseBtn.onclick = () => {
      playing = !playing
      playPauseBtn.textContent = playing ? 'Pause' : 'Play'
    }

    togglePollBtn.onclick = () => {
      polling = !polling
      togglePollBtn.textContent = polling ? 'Stop Polling' : 'Start Polling'
      if (polling) {
        const secs = Math.max(1, Number(pollSecsInput.value) || 5)
        pollTimer = setInterval(checkForNewFrames, secs * 1000)
      } else if (pollTimer) {
        clearInterval(pollTimer)
        pollTimer = null
      }
    }

    loadAll().catch(err => {
      console.error(err)
      statusEl.textContent = 'error: ' + err.message
    })
  </script>
</body>
</html>